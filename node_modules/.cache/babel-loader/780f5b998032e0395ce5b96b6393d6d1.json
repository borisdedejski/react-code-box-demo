{"ast":null,"code":"\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar hljs = __importStar(require(\"highlight.js\"));\n\nvar parse5 = __importStar(require(\"parse5\"));\n\nvar parse5_htmlparser2_tree_adapter_1 = __importDefault(require(\"parse5-htmlparser2-tree-adapter\"));\n\nvar theme_1 = require(\"./theme\");\n\nfunction colorizeNode(node, theme, context) {\n  if (theme === void 0) {\n    theme = {};\n  }\n\n  switch (node.type) {\n    case 'text':\n      {\n        var text = node.data;\n\n        if (context === undefined) {\n          return (theme.default || theme_1.DEFAULT_THEME.default || theme_1.plain)(text);\n        } else {\n          return text;\n        }\n      }\n\n    case 'tag':\n      {\n        var hljsClass = /hljs-(\\w+)/.exec(node.attribs.class);\n\n        if (hljsClass) {\n          var token_1 = hljsClass[1];\n          var nodeData = node.childNodes.map(function (node) {\n            return colorizeNode(node, theme, token_1);\n          }).join('');\n          return (theme[token_1] || theme_1.DEFAULT_THEME[token_1] || theme_1.plain)(nodeData);\n        } // Return the data itself when the class name isn't prefixed with a highlight.js token prefix.\n        // This is common in instances of sublanguages (JSX, Markdown Code Blocks, etc.)\n\n\n        return node.childNodes.map(function (node) {\n          return colorizeNode(node, theme);\n        }).join('');\n      }\n  }\n\n  throw new Error('Invalid node type ' + node.type);\n}\n\nfunction colorize(code, theme) {\n  if (theme === void 0) {\n    theme = {};\n  }\n\n  var fragment = parse5.parseFragment(code, {\n    treeAdapter: parse5_htmlparser2_tree_adapter_1.default\n  });\n  return fragment.childNodes.map(function (node) {\n    return colorizeNode(node, theme);\n  }).join('');\n}\n/**\n * Apply syntax highlighting to `code` with ASCII color codes. The language is automatically\n * detected if not set.\n *\n * ```ts\n * import {highlight} from 'cli-highlight';\n * import * as fs from 'fs';\n *\n * fs.readFile('package.json', 'utf8', (err: any, json: string) => {\n *     console.log('package.json:');\n *     console.log(highlight(json));\n * });\n * ```\n *\n * @param code The code to highlight\n * @param options Optional options\n */\n\n\nfunction highlight(code, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var html;\n\n  if (options.language) {\n    html = hljs.highlight(options.language, code, options.ignoreIllegals, options.continuation).value;\n  } else {\n    html = hljs.highlightAuto(code, options.languageSubset).value;\n  }\n\n  return colorize(html, options.theme);\n}\n\nexports.highlight = highlight;\n/**\n * Returns all supported languages\n */\n\nfunction listLanguages() {\n  return hljs.listLanguages();\n}\n\nexports.listLanguages = listLanguages;\n/**\n * Returns true if the language is supported\n * @param name A language name, alias or file extension\n */\n\nfunction supportsLanguage(name) {\n  return !!hljs.getLanguage(name);\n}\n\nexports.supportsLanguage = supportsLanguage;\nexports.default = highlight;\n\n__export(require(\"./theme\"));","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hljs = __importStar(require(\"highlight.js\"));\nvar parse5 = __importStar(require(\"parse5\"));\nvar parse5_htmlparser2_tree_adapter_1 = __importDefault(require(\"parse5-htmlparser2-tree-adapter\"));\nvar theme_1 = require(\"./theme\");\nfunction colorizeNode(node, theme, context) {\n    if (theme === void 0) { theme = {}; }\n    switch (node.type) {\n        case 'text': {\n            var text = node.data;\n            if (context === undefined) {\n                return (theme.default || theme_1.DEFAULT_THEME.default || theme_1.plain)(text);\n            }\n            else {\n                return text;\n            }\n        }\n        case 'tag': {\n            var hljsClass = /hljs-(\\w+)/.exec(node.attribs.class);\n            if (hljsClass) {\n                var token_1 = hljsClass[1];\n                var nodeData = node.childNodes\n                    .map(function (node) { return colorizeNode(node, theme, token_1); })\n                    .join('');\n                return (theme[token_1] || theme_1.DEFAULT_THEME[token_1] || theme_1.plain)(nodeData);\n            }\n            // Return the data itself when the class name isn't prefixed with a highlight.js token prefix.\n            // This is common in instances of sublanguages (JSX, Markdown Code Blocks, etc.)\n            return node.childNodes.map(function (node) { return colorizeNode(node, theme); }).join('');\n        }\n    }\n    throw new Error('Invalid node type ' + node.type);\n}\nfunction colorize(code, theme) {\n    if (theme === void 0) { theme = {}; }\n    var fragment = parse5.parseFragment(code, {\n        treeAdapter: parse5_htmlparser2_tree_adapter_1.default,\n    });\n    return fragment.childNodes.map(function (node) { return colorizeNode(node, theme); }).join('');\n}\n/**\n * Apply syntax highlighting to `code` with ASCII color codes. The language is automatically\n * detected if not set.\n *\n * ```ts\n * import {highlight} from 'cli-highlight';\n * import * as fs from 'fs';\n *\n * fs.readFile('package.json', 'utf8', (err: any, json: string) => {\n *     console.log('package.json:');\n *     console.log(highlight(json));\n * });\n * ```\n *\n * @param code The code to highlight\n * @param options Optional options\n */\nfunction highlight(code, options) {\n    if (options === void 0) { options = {}; }\n    var html;\n    if (options.language) {\n        html = hljs.highlight(options.language, code, options.ignoreIllegals, options.continuation).value;\n    }\n    else {\n        html = hljs.highlightAuto(code, options.languageSubset).value;\n    }\n    return colorize(html, options.theme);\n}\nexports.highlight = highlight;\n/**\n * Returns all supported languages\n */\nfunction listLanguages() {\n    return hljs.listLanguages();\n}\nexports.listLanguages = listLanguages;\n/**\n * Returns true if the language is supported\n * @param name A language name, alias or file extension\n */\nfunction supportsLanguage(name) {\n    return !!hljs.getLanguage(name);\n}\nexports.supportsLanguage = supportsLanguage;\nexports.default = highlight;\n__export(require(\"./theme\"));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}